---
関数の実行の仕組み
---

関数を実行するということは関数が持つ命令をループで処理していくということになる。
本章ではWasm Runtimeがどのように関数を処理するかについて解説していく。

## 命令の実行

Wasm Runtimeでは命令の実行は、大きく分けると次のステップがある。

1. プログラムカウンタを使って命令を取得
2. 取得した命令を処理
    - このステップではスタックやローカル変数等の操作も行う
3. プログラムカウンタをカウントアップ

プログラムカウンタは次に実行する命令の番地を指す値のこと。
Wasm Runtimeでは命令は配列となっているので、プログラムカウンタは配列のインデックスの値となる。

これを疑似コードで示すと次のようになる。

```rust
let instructions = vec![...];      // 命令列
let mut stack: Vec<i32> = vec![];  // スタック
let mut locals: Vec<i32> = vec![]; // ローカル変数
let mut pc: usize = 0;             // プログラムカウンタ

loop {
    if let Some(instruction) = instructions.get(pc) else {
        break;
    };

    match instruction {
        inst::LocalGet => { ... }
        inst::I32Add => { ... }
        ...
    }

    pc += 1;
}
```

## フレーム

フレームは関数の実行に必要な次の情報を持つデータ構造のこと。
各種項目の概要については後述する。

- プログラムカウンタ（pc）
- スタックポインタ（sp）
- 命令列（instructions）
- 戻り値の個数（arity）
- 引数・ローカル変数（locals）

関数を実行するときはフレームを作成して、これらの情報を元に処理していく。
今回実装するWasm Runtimeではフレームを次のように表現している。

```rust
#[derive(Default)]
pub struct Frame {
    pub pc: isize,
    pub sp: usize,
    pub insts: Vec<Instruction>,
    pub arity: usize,
    pub locals: Vec<Value>,
}
```

## コールスタック

フレームを保持するためのスタック領域のこと。
関数を実行するときにフレームを作成して、それをコールスタックに`push`する。
関数の実行が終わるとコールスタックから`pop`される。

コールスタックとフレーム、命令実行の関係性を図に示すと次のとおりである。
プログラムカウンタと命令列は命令フェッチ時に使用され、それ以外の情報は命令を処理する時に使われる。

![](./images/about_execution.drawio.png)

## スタックポインタ

コールスタックは関数を実行するたびに積まれるが、スタックは常にひとつである。
そのため、関数間では共通のスタック領域を使うことになる。

共通の領域のため、関数実行が終わったタイミングでスタックを巻き戻す必要がある。

例えばスタックに値を積む処理を持つ`func1`と`func2`があるとする。
`func1`の処理中に`func2`を呼び出す場合、`func2`の処理中に値がスタックに積まれた状態で`func2`の処理が終わり、`func1`の処理に戻るときスタックに`func2`で積んだ値が残ったままになってしまう。
そのため、`func1`が`func2`を呼び出した時点のスタック状態に巻き戻す必要がある。
その際にスタックをどこまで巻き戻すかの情報が必要で、それがスタックポインタである。

## 引数・ローカル変数

Wasmの関数は引数とローカル変数を持つことができる。
引数は実質ローカル変数なので、フレームの`locals`に保存することになる。

関数から関数を呼び出す際に、引数をどのように関数にわたすかについて少し解説する。
まず、関数を実行する前にフレームを作成するが、引数を受け取る関数がある場合はスタックから引数を`pop`して、`locals`に`push`する。

これにより、関数を実行する際にローカル変数を使えるようになる。

## 戻り値の個数

Wasmの関数は戻り値を返すことができる。
関数の実行が終わってスタックが巻き戻されるときに、戻り値がある場合は先にスタックから値を`pop`してから巻き戻す。
その後、`pop`した値をスタックに`push`する。

これにより、関数の実行結果がスタックに積まれた状態になり、呼び出し元で続きの処理を行うことができる。
関数の実行結果がスタックに積まれるということは、`i32.const 1`のようにスタックに`1`を`push`する処理と同等と考えるとイメージしやすいかもしれない。

## まとめ
Wasmにおける関数の実行の仕組みについて解説した。
実際に実装してみないと理解できないところもあるので、次章では実際に実装をして理解を深めていく。
